"""Utilities for loading recorded episodes."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Iterator, List, Sequence


class EpisodeReader:
    """Read episode data generated by :class:`EpisodeWriter`.

    Parameters
    ----------
    json_path:
        Path to the ``data.json`` file generated by the recorder.
    """

    def __init__(self, json_path: str | Path) -> None:
        self.json_path = Path(json_path)
        self._data = self._load_json()

    def _load_json(self) -> Dict[str, Any]:
        if not self.json_path.exists():
            raise FileNotFoundError(f"Episode file not found: {self.json_path}")
        with self.json_path.open("r", encoding="utf-8") as file:
            return json.load(file)

    @property
    def info(self) -> Dict[str, Any]:
        """Metadata describing the episode."""
        return self._data.get("info", {})

    @property
    def frequency(self) -> float:
        """Recording frequency in Hz."""
        image_info = self.info.get("image", {})
        return float(image_info.get("fps", 30))

    def iter_items(self) -> Iterator[Dict[str, Any]]:
        """Iterate over raw item dictionaries."""
        yield from self._data.get("data", [])

    def iter_dual_arm_actions(self) -> Iterator[Sequence[float]]:
        """Yield concatenated joint positions for both arms.

        Each item yields a sequence of 14 values containing the left arm
        joints followed by the right arm joints.  Items missing data for either
        arm are skipped.
        """
        for item in self.iter_items():
            actions = item.get("actions", {})
            left = actions.get("left_arm", {}).get("qpos")
            right = actions.get("right_arm", {}).get("qpos")
            if left is not None and right is not None:
                yield list(left) + list(right)
